#include "sgx_eid.h"
#include "DecryptEnclave_t.h"
#include "EnclaveMessageExchange.h"
#include "error_codes.h"
#include "Utility_E2.h"
#include "sgx_dh.h"
#include "sgx_utils.h"
//#include "se_memcpy.h"
#include <map>


static char hibe_setup_keys[4096];
static int32_t hibe_setup_keys_size = 0;
static int depth_st = 0;

extern "C" char *setup_hibe(int32_t depth, char *seed_buf, int32_t seed_size, int32_t *out_size);
extern "C" int decrypt_hibe_integers(int32_t depth, char *setup_params, int32_t *identity, int32_t identity_size, char *seed_buf, int32_t seed_size, char *ciphertext,
		int32_t ciphertext_size, char *encapsulated_key);
extern "C" int decrypt_hibe_strings_depth(int32_t depth, char *setup_params, char *seed_buf, int32_t seed_size, char *ciphertext, int32_t ciphertext_size, char *encapsulated_key, char *out_buf);

int init_hibe(int depth)
{
	//char seed[32] = {0x0};
	int32_t out_size;

	char *hibe_setup_params = setup_hibe(depth, NULL, 0, &out_size);
	if (out_size <= 0)
		return -1;
	if (out_size > 4096)
		return -2;
	
	hibe_setup_keys_size = out_size;
	memcpy(hibe_setup_keys, hibe_setup_params, hibe_setup_keys_size);
	
	depth_st = depth;

	return out_size;
}
//char ciphertext[] = "\xa3\xf7\x82\xf3\x82\x91\x4e\x53\x7b\x32\x73\x37\x26\xd5\xf6\xc9";
//char encapsulated_key[] = "\xba\x55\x11\xde\x7a\x54\x65\x7c\x3a\xf3\xcf\xad\x62\x85\xae\x3a\x53\xee\x19\x76\xe2\xac\xd5\x5f\xf8\xc1\x94\x6e\xa\x1f\x33\x29\xd9\xd9\x96\x55\x53\x2b\xcb\xd1\x6\xb2\x67\xc9\xb8\x3f\x38\xa\xd8\xc5\xa9\xe8\x92\x4e\x48\xbf\xcd\x18\x71\x58\x93\xa4\xf5\x2\x49\x3b\x6\x81\x1d\x3e\xb5\x9\x1c\x20\x53\x53\x69\x37\xfc\x70\xe2\xb8\xf6\x9e\x72\xa2\xc\xf0\x30\x1f\xa9\x2\x63\xd7\x34\x2\x0\xe1\x50\xd2\xae\x1f\x72\x29\x7\x6d\x19\xde\xb1\xa8\x69\xb6\xf\xdd\x11\x62\xb7\x17\x51\xa\x5f\x52\x70\x57\x24\x49\xa8\x3\x79\xc8\xdb\x5c\x80\x59\x32\xb7\xa9\xb4\xa\x1\x9\x6e\x5d\x1e\xf0\x64\x44\x6e\x2f\x3d\x7\xe\x43\x38\x18\xb5\x4\x4f\x72\xde\x36\xca\x63\xcb\x16\x4a\xbc\x96\x96\x1\x7c\xa3\x79\xa4\xbb\xba\xe6\x5e\x5e\x14\xd7\xe\xa5\x6\x24\xc0\x94\xdb\xba\xb8\x74\x7f\xe\xdd\x2b\xfd\xad\x72\x49\x15\x8e\xeb\x8d\xac\xa3\xe6\xd2\x2\xbb\x1d\x51\x13\x7c\x38\xe9\x59\xe5\x91\x58\xa7\x39\x24\x87\x1b\x7f\xa1\x48\x45\x73\xd5\x76\xa9\x1a\xc7\xbe\xdd\xec\xfb\x56\x8c\x43\x79\x5\x34\xa3\x72\xbc\x12\xde\xd7\xc6\x80\xa1\x8e\x2c\xec\xa7\xad\x89\xc8\xb\xa4\x65\xac\xa\x97\xf3\xd6\x1\x4d\xf7\x43\x45\x12\xee\xcb\xff\x2c\xe3\xfb\x2\x8a\x28\x76\xfe\x66\xc1\x8e\xe0\x7f\x8b\x25\x8e\x28\x3b\x1\x0\x15\x5c\x15\x69\x98\x44\x48";

//char setup_params[] = "\x00\x1f\x95\x56\xb7\x20\x1b\xe5\xaf\xaa\x9e\x48\x13\xd6\x01\x57\xe1\xee\x85\x51\x34\x4d\x4f\x18\x10\xc2\x6b\x9d\xe0\xcd\x47\x86\x1f\x9a\xc5\x76\x11\x83\x94\x34\x32\x51\x03\x81\x26\x87\xaa\x09\x84\xc1\xdc\xe6\x2c\x84\x08\x94\x89\x52\x41\x00\x35\x2d\x8c\x53\xaa\xaa\xe8\x6f\xc2\xf2\xdc\x68\x68\x39\xe8\xce\xc6\xe7\xc2\x40\x1c\xd5\x34\xb8\xf6\x42\x8d\x64\x5f\xe4\x00\x8d\xc3\xea\x0f\x19\xaa\x8a\x8c\x55\x15\xf6\x61\x4a\x98\x9c\x57\x6e\x36\x62\xd8\xa6\xc3\x8b\x5b\xcb\x8e\xbe\x36\xee\x2d\xd1\x23\x54\xbf\xc1\xf5\xd0\xb3\x32\x1a\xd4\x3e\xa1\x36\x37\x7c\x38\xfc\xa5\x66\x39\x97\x00\x20\x10\xa8\x66\xf2\x82\xa4\x44\x57\x6e\xba\x82\x73\xfd\x48\x41\xeb\xbb\xf9\xdf\x25\xab\x44\x11\xe6\x45\x7f\x2f\x3a\x21\xfb\x2b\x7d\xd1\xce\xef\x07\xcd\x86\x79\x6c\x3a\xe5\x86\xc8\xa1\x02\x02\x00\x00\x00\x00\x00\x00\x00\x00\x16\x0c\x53\xfd\x90\x87\xb3\x5c\xf5\xff\x76\x99\x67\xfc\x17\x78\xc1\xa1\x3b\x14\xc7\x95\x4f\x15\x47\xe7\xd0\xf3\xcd\x6a\xae\xf0\x40\xf4\xdb\x21\xcc\x6e\xce\xed\x75\xfb\x0b\x9e\x41\x77\x01\x12\x71\x22\xe7\x0c\xd5\x93\xac\xba\x8e\xfd\x18\x79\x1a\x63\x22\x8c\xce\x25\x07\x57\x13\x5f\x59\xdd\x94\x51\x40\x50\x29\x58\xac\x51\xc0\x59\x00\xad\x3f\x8c\x1c\x0e\x6a\xa2\x08\x50\xfc\x3e\xbc\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x1e\x38\x5f\x9e\x9a\x47\x50\x5e\x8a\xf0\xb7\x8c\xc5\xee\xee\x0d\x3e\x14\xdb\x4a\xf8\x32\xcd\xff\x07\x82\x5c\x8e\xb3\xee\xc5\x12\xd2\xb7\x9a\x88\x43\x0b\x63\x40\x49\x33\x08\xf4\xec\xab\xf2\x18\xbe\x2a\x55\x0d\x7b\x5f\xbf\x4b\x9d\x24\xb2\x7c\xdc\xe8\x10\x6c\xb6\xd6\x80\xfd\xbc\x61\x70\x68\x58\xa4\x50\x05\x1f\x8d\x2f\x50\x81\x5e\x31\x2f\xa9\xea\xda\x9e\x5d\x7c\xb5\xac\x12\x08\xc1\x04\x00\x00\x00\x00\x00\x00\x00\x00\x21\xa4\xf9\x91\x5e\xa6\xee\x19\x06\xb5\xb8\x74\x70\xe6\x97\x4a\xaf\x3e\x12\x93\x38\x19\x9e\xa3\xf8\xd6\xca\x3b\xb2\x7c\x53\x4f\xad\xa2\x7d\x06\xce\xd2\x25\x89\xd1\x64\x8e\xd3\x72\xda\x64\x01\x8e\x39\x30\x95\x83\xe3\x2d\x91\x25\x5b\xbb\x4a\x9b\xb8\xfe\x3f\xc6\x2b\x95\x06\x51\x70\xf5\x8a\xc0\xcf\xb8\x29\x17\x9f\x0b\x6d\x01\x98\x29\xa4\x67\x0b\x9f\x3d\x5c\x06\x6c\xc7\x56\x9a\x97\x17\xb5\xb0\x63\x73\xc5\xbb\x59\xf0\x43\xcc\x4a\x95\xf9\xd9\xa8\x24\x00\x71\x66\xb5\x96\x78\x3d\x56\x34\xc5\x38\xfb\x6d\xf1\x01\x32\x5b\xbb\xf1\x99\xe9\x43\x58\x16\xf0\x48\x15\xb0\xe8\xd2\x05\x18\x18\x40\x62\xd0\x59\xad\x18\x80\x61\xe8\x6a\xdb\xcb\xa1\xf0\xc7\x28\x11\x48\xc3\x17\x23\x8f\x01\x3b\x9c\x4b\xb4\x06\x85\x12\x82\xeb\xaf\x2d\xd7\x4c\x31\x11\x61\x7f\x6e\x46\x23\x47\x9d\xb3\x06\x00\x00\x00\x00\x00\x00\x00\x00\x2f\x79\x0b\x40\x0c\x80\xc5\xda\x39\xc4\x8d\xa3\xf9\x8f\xc9\x43\x06\x99\x51\x99\x29\x6a\x84\xd9\x0b\x6e\x95\x78\xf1\x17\x07\x6a\x43\x70\xfa\x51\x40\xe4\xd8\x18\x24\x1b\xe2\xba\x48\x8b\x99\x0e\x55\xa8\x43\x2b\x44\x13\xda\x63\x8e\xaf\x1c\x3d\x69\x40\x3c\x2b\xf4\xc1\x1a\x39\x44\xdc\xbd\x9f\x1b\x59\xca\x3b\xc6\x64\x07\x61\x8f\x33\xed\x4e\xcf\x58\x8b\xd7\xe9\x3d\x41\x1f\x71\xd7\x1f\x17\x92\x98\x13\x78\xe1\x97\xf0\x2e\xfb\xe9\x5d\x37\x40\xa8\x2c\x1a\x7c\x2f\xe2\xfd\xb1\x40\x40\xd0\x8d\xf5\x53\xe5\x03\x78\x2e\x2d\x20\xda\x1e\x40\xdc\x9c\x74\xe3\x46\xa5\xf8\x7e\x1b\x65\x0e\x18\x2e\xa1\x24\x8a\x95\x61\x15\xfd\x85\xd6\xcb\x7a\x6d\xfc\xe5\xe7\x92\xa5\xcf\xee\xa4\x47\xf7\x79\x0e\x69\x22\x07\x03\xda\xb0\xcc\x90\x07\xf2\x81\x43\x11\x0d\x44\xf6\x69\xfd\x9e\x6c\x5a\x4d\x06\x00\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x70\x2f\xe8\x90\x6a\x55\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00";

extern "C" uint32_t bellerophon_decrypt(dh_session_t* session_info, char* decrypted_data, char** resp_buffer, size_t* resp_length)
{
	//TODO: Use session_info when using the 
	ms_in_msg_exchange_t *ms = (ms_in_msg_exchange_t *)decrypted_data;
	decryption_request_t *dec_req;

	if (!ms || !resp_length)
		return INVALID_PARAMETER_ERROR;
	if (ms->inparam_buff_len != sizeof(decryption_request_t))
		return ATTESTATION_ERROR;

	dec_req = (decryption_request_t *)ms->inparam_buff;
	//if (memcmp(dec_req->enc_key, ciphertext, 16) || memcmp(dec_req->encapsulated_key, encapsulated_key, dec_req->encapsulated_key_size) )
	//	return ATTESTATION_ERROR;
	unsigned char b[] = {0x61, 0x61, 0x61, 0xa};

	unsigned char b1[] = {0x61, 0x61, 0x61, 0xa, 0xa};
	//ocall_print_buffer(b, 4);
	int32_t ids[4] = {1, 2, 3, 4};	
	//ocall_print_buffer(b, 4);
	//char seed[32] = {0x0};
	//char key[16] = {0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa};
	//char key1[16];
	//memcpy(key1, ciphertext, 16);
	//char *setup_params_copy = (char *)malloc(832);
	//memcpy(setup_params_copy, setup_params, 832);
	//ocall_print_buffer((unsigned char *)ciphertext, 16);
	int ret = decrypt_hibe_strings_depth(depth_st, (char *)hibe_setup_keys, NULL, 0, (char *)dec_req->enc_key, 16, (char *)dec_req->encapsulated_key, NULL);
	/*if (ret == 100) {
		ocall_print_buffer(b1, 5);
		return ATTESTATION_ERROR;
	}*/

	if (ret < 0)
		return ATTESTATION_ERROR;

	//ocall_print_buffer(b, 4);
	
	if(bellerophon_marshal_message_exchange_response(resp_buffer, resp_length, (char *)dec_req->enc_key, 16) != SUCCESS)
	//if(bellerophon_marshal_message_exchange_response(resp_buffer, resp_length, (char *)key, 16) != SUCCESS)
        	return MALLOC_ERROR;
	//ocall_print_buffer(b, 4);

	return SUCCESS;
}
